/**

@mainpage 15-410 Project 3

@author Jonathan Ong (jonathao)
@author Evan Palmer (esp)

Same drill as last time.

*/


Scheduler

    round robin

    progress guarantees


Mutexes / Cvars

    don't yield loop

    disable interrupts

    nodes on stack


Virtual Memory

    frame allocation (implicit list)

    vm_map

    zfod

    recording allocations

Exceptions
    
    No kernel mode faults are allowed  (vm_back)


Premptability

    We undersand context vs mode switch


Wait vanish:

    Memory is freed quickly by acquire malloc (at most one tcb/ppd unfreed)

    How races are managed

Readline

    Doesn't disable interrupts for so long
    
    Suspends threads until they need to be awoken

Sleep

Our sleep function is implemented by adding threads to a sorted linked list. In
order to read from the list, threads must hold a mutex, and in order to modify
the list, interrupts must be disabled.

This allows the sleep syscall to grab sleeper list lock, and search for the
position where the current thread should be added to that list. It can then
disable interrupts and add the thread to the list. Finally when the the thread
is awoken, it removes itsself from the sleeper list after grabbing the lock and
disabling interrupts.

This ensures that even though the sleep syscall takes O(n) time in the number
of sleeping threads, interrupts are only disabled for O(1) time.

The scheduler needs only to check if the first item in the list is still
sleeping and is ready to wake up. This takes O(1) time and does not require
the list lock.

Exec / Fork
    
    Limited to processes with one thread, don't need any locks for any real
    period of time

Exec

    Zfod/Read only for text/bss/data/rodata and stack

General Syscalls

   Hold ppd lock when reading and writing to avoid races


Gettid

   Tcb stored on top of kernel stack, can be accessed with macro

Thread States (make runnable / deschedule)

    special state so they can't make kernel suspended threads runnable


